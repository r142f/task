DROP TABLE IF EXISTS UsersSegments, Users, Segments, Records CASCADE;

CREATE TABLE Users (
    UserId integer GENERATED BY DEFAULT AS IDENTITY,
    CONSTRAINT U_UserId_PK PRIMARY KEY (UserId)
);

CREATE TABLE Segments (
    SegmentId integer GENERATED ALWAYS AS IDENTITY,
    SegmentName varchar(255) NOT NULL,
    CONSTRAINT S_SegmentId_PK PRIMARY KEY (SegmentId),
    CONSTRAINT S_SegmentName_K1 UNIQUE (SegmentName)
);

CREATE TABLE UsersSegments (
    UserId integer NOT NULL,
    SegmentId integer NOT NULL,
    CONSTRAINT US_UserId_SegmentId_PK PRIMARY KEY (UserId, SegmentId),
    CONSTRAINT US_U_UserId_FK1 FOREIGN KEY (UserId) REFERENCES Users (UserId) ON DELETE CASCADE DEFERRABLE INITIALLY immediate,
    CONSTRAINT US_S_SegmentId_FK2 FOREIGN KEY (SegmentId) REFERENCES Segments (SegmentId) DEFERRABLE INITIALLY immediate
);

CREATE TYPE operation AS enum ('add', 'delete');

CREATE TABLE Records (
    RecordId integer GENERATED ALWAYS AS IDENTITY,
    UserId integer NOT NULL,
    SegmentName varchar(255) NOT NULL,
    Operation operation NOT NULL,
    Time timestamp DEFAULT (NOW() at time zone 'utc'),
    CONSTRAINT R_RecordId_PK PRIMARY KEY (RecordId),
    CONSTRAINT R_U_UserId_FK1 FOREIGN KEY (UserId) REFERENCES Users (UserId) ON DELETE CASCADE DEFERRABLE INITIALLY immediate
);

CREATE OR REPLACE FUNCTION DeleteSegmentBeforeHandler()
  RETURNS TRIGGER
  AS $$
BEGIN
  SET constraints US_S_SegmentId_FK2 DEFERRED;

  DELETE FROM UsersSegments
  WHERE SegmentId = OLD.SegmentId;

  RETURN OLD;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER DeleteSegmentBeforeTrigger
BEFORE DELETE ON Segments
FOR EACH ROW
EXECUTE PROCEDURE DeleteSegmentBeforeHandler();

CREATE OR REPLACE FUNCTION InsertUsersSegmentsBeforeHandler()
  RETURNS TRIGGER
  AS $$
BEGIN
  IF NOT EXISTS (
    SELECT FROM Users WHERE UserId = NEW.UserId
  ) THEN
    INSERT INTO Users (UserId) VALUES (NEW.UserId);
  END IF;

  RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER InsertUsersSegmentsBeforeTrigger
BEFORE INSERT ON UsersSegments
FOR EACH ROW
EXECUTE PROCEDURE InsertUsersSegmentsBeforeHandler();

CREATE OR REPLACE FUNCTION DeleteUsersSegmentsAfterHandler()
  RETURNS TRIGGER
  AS $$
BEGIN
  INSERT INTO Records (UserId, SegmentName, Operation)
  VALUES (
    OLD.UserId,
    (
      SELECT SegmentName
      FROM Segments
      WHERE SegmentId=OLD.SegmentId
    ),
    'delete'
  );

  RETURN OLD;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER DeleteUsersSegmentsAfterTrigger
AFTER DELETE ON UsersSegments
FOR EACH ROW
EXECUTE PROCEDURE DeleteUsersSegmentsAfterHandler();

CREATE OR REPLACE FUNCTION InsertUsersSegmentsAfterHandler()
  RETURNS TRIGGER
  AS $$
BEGIN
  INSERT INTO Records (UserId, SegmentName, Operation)
  VALUES (
    NEW.UserId,
    (
      SELECT SegmentName
      FROM Segments
      WHERE SegmentId=NEW.SegmentId
    ),
    'add'
  );

  RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER InsertUsersSegmentsAfterTrigger
AFTER INSERT ON UsersSegments
FOR EACH ROW
EXECUTE PROCEDURE InsertUsersSegmentsAfterHandler();